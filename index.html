<script>
  // =========================
  //  æ¨ã—æ´»ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆï¼ˆindexå®Œçµç‰ˆï¼‰
  //  - æ¬¡ã®è©¦åˆ â†’ æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ
  //  - æ—¥ä»˜ã¯ localStorage ã«ä¿å­˜ï¼ˆãƒœã‚¿ãƒ³ã§éšæ™‚æ›´æ–°ï¼‰
  // =========================

  // è¡¨ç¤ºãƒ»è¨ˆç®—è¨­å®šï¼ˆå¿…è¦ãªã‚‰ã“ã“ã ã‘ï¼‰
  const LOCALE = "ja-JP";
  const TIMEZONE = "Asia/Tokyo";
  const STORAGE_KEY = "oshi_widget_data_v1";

  // åˆæœŸãƒ‡ãƒ¼ã‚¿ï¼ˆæœ€åˆã ã‘ä½¿ã‚ã‚Œã‚‹ã€‚ä»¥å¾Œã¯ãƒœã‚¿ãƒ³ã§æ›´æ–°ã—ãŸå†…å®¹ãŒå„ªå…ˆï¼‰
  const DEFAULT_DATA = {
    oshiName: "æ¨ã—",
    birthday: "2000-08-06", // å¹´ã¯ä»®ã§OKï¼ˆæ¯å¹´ã®æ¬¡ã®èª•ç”Ÿæ—¥ã‚’è¨ˆç®—ï¼‰
    events: [
      { name: "æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ", date: "2026-01-05" }
    ]
  };

  const $ = (id) => document.getElementById(id);

  function parseYMD(ymd) {
    // timezoneã‚ºãƒ¬ã‚’é¿ã‘ã‚‹ãŸã‚ã€ŒUTCæ­£åˆã€ã§æ‰±ã†
    const [y, m, d] = ymd.split("-").map(Number);
    return new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  }

  function tokyoTodayUTCNoon() {
    const now = new Date();
    const parts = new Intl.DateTimeFormat(LOCALE, {
      timeZone: TIMEZONE,
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(now);

    const y = parts.find(p => p.type === "year").value;
    const m = parts.find(p => p.type === "month").value;
    const d = parts.find(p => p.type === "day").value;
    return parseYMD(`${y}-${m}-${d}`);
  }

  function daysDiff(fromUTCNoon, toUTCNoon) {
    const ms = toUTCNoon - fromUTCNoon;
    return Math.round(ms / (1000 * 60 * 60 * 24));
  }

  function formatDate(ymd) {
    const dt = parseYMD(ymd);
    return new Intl.DateTimeFormat(LOCALE, {
      timeZone: TIMEZONE,
      year: "numeric",
      month: "long",
      day: "numeric",
      weekday: "short"
    }).format(dt);
  }

  function nextBirthday(birthdayYMD, baseDateUTCNoon) {
    const [, mm, dd] = birthdayYMD.split("-").map(Number);

    const yearNow = Number(new Intl.DateTimeFormat(LOCALE, {
      timeZone: TIMEZONE,
      year: "numeric"
    }).format(new Date()));

    let target = new Date(Date.UTC(yearNow, mm - 1, dd, 12, 0, 0));
    if (daysDiff(baseDateUTCNoon, target) < 0) {
      target = new Date(Date.UTC(yearNow + 1, mm - 1, dd, 12, 0, 0));
    }

    const y = target.getUTCFullYear();
    const m = String(target.getUTCMonth() + 1).padStart(2, "0");
    const d = String(target.getUTCDate()).padStart(2, "0");
    return { ymd: `${y}-${m}-${d}`, dt: target };
  }

  function setPill(el, diff) {
    el.classList.remove("today", "past");
    if (diff === 0) {
      el.textContent = "ğŸ‰ ä»Šæ—¥ï¼";
      el.classList.add("today");
    } else if (diff > 0) {
      el.textContent = `ã‚ã¨ ${diff}æ—¥`;
    } else {
      el.textContent = `${Math.abs(diff)}æ—¥ çµŒé`;
      el.classList.add("past");
    }
  }

  function loadData() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return structuredClone(DEFAULT_DATA);
      const parsed = JSON.parse(raw);

      // æœ€ä½é™ã®æ•´å½¢
      if (!parsed.oshiName) parsed.oshiName = DEFAULT_DATA.oshiName;
      if (!parsed.birthday) parsed.birthday = DEFAULT_DATA.birthday;
      if (!Array.isArray(parsed.events)) parsed.events = structuredClone(DEFAULT_DATA.events);
      return parsed;
    } catch {
      return structuredClone(DEFAULT_DATA);
    }
  }

  function saveData(data) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  function pickNearestUpcomingEvent(events, baseDateUTCNoon) {
    // æœªæ¥ã®æœ€çŸ­ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°ä¸€ç•ªè¿‘ã„éå»
    let bestFuture = null;
    let bestPast = null;

    for (const ev of events) {
      if (!ev?.date) continue;
      const dt = parseYMD(ev.date);
      const diff = daysDiff(baseDateUTCNoon, dt);

      if (diff >= 0) {
        if (!bestFuture || diff < bestFuture.diff) bestFuture = { ...ev, dt, diff };
      } else {
        if (!bestPast || diff > bestPast.diff) bestPast = { ...ev, dt, diff };
      }
    }
    return bestFuture || bestPast || null;
  }

  function render() {
    const base = tokyoTodayUTCNoon();
    const data = loadData();

    // èª•ç”Ÿæ—¥
    $("bLabel").textContent = `æ¨ã—èª•ç”Ÿæ—¥ï¼ˆ${data.oshiName || "æ¨ã—"}ï¼‰`;
    const bTarget = nextBirthday(data.birthday, base);
    $("bDateText").textContent = formatDate(bTarget.ymd);
    setPill($("bCountdown"), daysDiff(base, bTarget.dt));

    // æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæœ€çŸ­ã‚’è‡ªå‹•è¡¨ç¤ºï¼‰
    const ev = pickNearestUpcomingEvent(data.events || [], base);
    $("eLabel").textContent = ev?.name || "æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ";
    $("eDateText").textContent = ev?.date ? formatDate(ev.date) : "â€”";
    setPill($("eCountdown"), ev ? ev.diff : 0);

    // æ›´æ–°æ™‚åˆ»
    const now = new Date();
    $("nowText").textContent =
      "æ›´æ–°: " +
      new Intl.DateTimeFormat(LOCALE, {
        timeZone: TIMEZONE,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      }).format(now);
  }

  function quickEdit() {
    const data = loadData();

    const name = prompt("æ¨ã—ã®å‘¼ã³åï¼ˆè¡¨ç¤ºç”¨ï¼‰", data.oshiName);
    if (name !== null && name.trim() !== "") data.oshiName = name.trim();

    const b = prompt("æ¨ã—ã®èª•ç”Ÿæ—¥ï¼ˆYYYY-MM-DD / å¹´ã¯ä»®ã§OKï¼‰", data.birthday);
    if (b !== null && /^\d{4}-\d{2}-\d{2}$/.test(b.trim())) data.birthday = b.trim();

    // è¤‡æ•°ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã€Œåå‰@æ—¥ä»˜ã€ã§æ”¹è¡Œå…¥åŠ›ï¼ˆç°¡å˜ã§å¼·ã„ï¼‰
    // ä¾‹ï¼š
    // æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ@2026-01-05
    // ç¾åœ°äºˆå®š@2026-01-18
    const currentLines = (data.events || [])
      .map(ev => `${ev.name || "æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ"}@${ev.date}`)
      .join("\n");

    const lines = prompt(
      "ã‚¤ãƒ™ãƒ³ãƒˆä¸€è¦§ï¼ˆ1è¡Œ= åå‰@YYYY-MM-DD ï¼‰\nä¾‹ï¼‰æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ@2026-01-05",
      currentLines || "æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ@2026-01-05"
    );

    if (lines !== null) {
      const events = lines
        .split("\n")
        .map(s => s.trim())
        .filter(Boolean)
        .map(row => {
          const [n, d] = row.split("@").map(x => (x || "").trim());
          return { name: n || "æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ", date: d };
        })
        .filter(ev => /^\d{4}-\d{2}-\d{2}$/.test(ev.date));

      // 1å€‹ã‚‚æ­£ã—ã„æ—¥ä»˜ãŒãªã‘ã‚Œã°æ—¢å­˜ã‚’ä¿æŒ
      if (events.length > 0) data.events = events;
    }

    // è¡¨ç¤ºåã¯ã€Œæ¬¡ã®è©¦åˆã€ã§ã¯ãªãã€Œæ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã€ã¸å¯„ã›ã‚‹
    // ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã§è‡ªç”±ã«ã§ãã‚‹ã‘ã©ã€ç©ºã®æ™‚ã¯ã“ã‚Œï¼‰
    data.events = (data.events || []).map(ev => ({
      name: ev.name || "æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆ",
      date: ev.date
    }));

    saveData(data);
    render();
  }

  // ===== åˆæœŸåŒ– =====
  // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãŒãªã‘ã‚Œã°ä¿å­˜ã—ã¦ãŠãï¼ˆåˆå›ã§ã‚‚å‹•ãï¼‰
  if (!localStorage.getItem(STORAGE_KEY)) saveData(structuredClone(DEFAULT_DATA));

  // ãƒœã‚¿ãƒ³ã®idã¯ã€ã‚ãªãŸã®HTMLã«åˆã‚ã›ã¦ã­
  // ä¾‹ï¼š<button id="editBtn">æ—¥ä»˜ã‚’å¤‰æ›´</button>
  const editBtn = document.getElementById("editBtn");
  if (editBtn) editBtn.addEventListener("click", quickEdit);

  render();
  setInterval(render, 60 * 60 * 1000); // 1æ™‚é–“ã”ã¨æ›´æ–°
</script>
